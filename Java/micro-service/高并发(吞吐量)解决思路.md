### 一、高可用
1. 负载均衡、反向代理：

        作用：将全部的网络请求均衡地分布到其它服务器，合理管理网络流量。
        LVS：软件负载均衡器；F5：硬件负载均衡器。
        Nginx：软件负载均衡器、反向代理服务器。

2. 隔离：

        作用：将系统或资源分割开，保障服务间的相互不影响和可用性。

    隔离常用手段：

    1.) 线程隔离：核心业务线程池、非核心业务线程池。基于servlet3的线程隔离术，tomcat7之后版本引入了servlet3，它基于NIO能处理更大的并发数。
        * 通过异步化不会获得更快的响应时间，但提升了整体的吞吐量和更高的灵活性，根据业务重要性进行分级，对不同的线程池进行监控、运维和降级等处理。
    2.) 进程隔离：拆分多个子系统来实现物理隔离。
    3.) 集群隔离：部署多个服务集群（常规服务分组，秒杀服务分组）
    4.) 机房隔离：多个机房部署，本机房服务正常只调用本机房服务，当其中一个机房发生问题是，通过负载均衡将请求全部切到另一个机房。
    5.) 读写隔离：通过主从模式将读和写集群分离，如MySQL、Redis。
    6.) 动静隔离：将动态内容和静态资源分离，静态资源放在CDN上。防止访问量太大导致宽带被打满，从而出现不可用。
    7.) 爬虫隔离：过滤恶意IP，分流到固定分组服务。保证正常流量可用。

图2.1
3. 限流：

    作用：一个时间窗口内的请求进行限速来保护系统，达到限制速率拒绝服务，从而保护系统可用性。

    限流算法：

    1.) 令牌桶：存放固定容量令牌的桶，按照固定速率往桶里添加令牌。桶满时，新添加的令牌被丢弃或拒绝。允许一定程度突发流量。算法实现上，可用乐观锁CAS(Compare and Swap 比较并交换)实现，AtomicInteger。

    2.) 漏桶：固定容量的漏桶，按照固定速率流出水滴。平滑突发流入速率。算法实现上，可以使用一个BlockingQueue表示漏桶，请求进来时放入这个BlockingQueue中。另起一个线程以固定的速率从BlockingQueue中取出请求，再提交给业务线程池处理。漏桶算法有个弊端：无法应对短时间的突发流量 。

    3.) 计数器：限制总并发数，Redis+Lua实现。

图3.1
4. 降级：

    作用：保证核心服务可用。

    降级手段：自动开关降级、人工开关降级、读服务降级、写服务降级等。

    通过配置中心设置降级开关；可使用Hystrix实现降级、熔断。

5. 超时与重试机制：

    * 如果应用不设置超时，可能导致请求响应慢，慢请求累积导致连锁反应，甚至造成应用雪崩。

    * 设置超时时间，重试次数（不超过3次）

    * Nginx、Tomcat、中间件客户端、数据库客户端、NoSQL客户端、业务超时、前端Ajax超时等

6. 回滚机制：

    代码库回滚、数据版本回滚、静态资源版本回滚等。

7. 压测与预案：

    系统压测、应急预案。

二、高并发
1. 缓存：

    应用及缓存：堆内缓存、堆外缓存、分布式缓存。

    HTTP缓存：根据服务器端返回的缓存设置响应头将响应内容缓存到浏览器。减少浏览器端和服务器端之间来回传输数据量，节省带宽。

    多级缓存：整个系统架构的不同系统层级进行数据缓存，以提升访问效率。Nginx本地缓存、分布式缓存、Tomcat堆缓存。

    * 可扩展分布式缓存常用一致性哈希算法。

    * 考虑更新缓存与原子性，缓存击穿、缓存雪崩问题。

2. 连接池、线程池：

    连接池：如数据库连接池、Redis连接池、HTTP连接池，通过复用TCP连接减少创建和释放连接的时间来提升性能。

    线程池：线程池也是类似，通过复用线程提升性能。ThreadPoolExecutor，根据任务类型是IO密集型还是CPU密集型、CPU核数，设置合理的线程池大小、队列大小、拒绝策略。

3. 异步并发：

    防止请求阻塞方案：异步、协程；Java不支持协程，则使用异步提升吞吐量。

    异步Future

    异步Callback

    异步CompletableFuture

4. 扩容：

    水平拆分和垂直拆分数据/应用来提升系统负载能力。理想情况，只需要增加机器就可以解决系统瓶颈。糟糕情况，需从架构层面重构甚至是重新设计。

    单体应用垂直扩容

    单体应用水平扩容

    应用拆分

    数据库拆分（分库分表）

5. 队列：

    作用：系统解耦、流量削峰、数据同步、扩展性、异步处理、缓冲等。

    * 保证最终一致性、不需要强一致性。（保证最终一致性的手段）

    * 考虑消息的重复处理，有序性问题。

三、总结：
    * 通过负载均衡和反向代理实现分流，通过限流保护服务免受雪崩之灾，通过降级实现部分可用、有损服务，通过隔离实现故障隔离，通过设置合理的超时与重试机制避免请求堆积造成雪崩，通过回滚机制快速修改错误版本；通过上述原则来保护系统，使得系统高可用。

    * 通过缓存、异步并发、连接池、线程池、扩容、消息队列、分布式任务等高并发原则来提升系统吞吐量。

转载：https://www.jianshu.com/p/0ec850e17f2a
